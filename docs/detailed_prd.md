# 상세 제품 요구사항 문서 (Detailed PRD)
## 카카오톡 오픈채팅 자동화 솔루션 v2.0

---

## 📋 개요

### 프로젝트 배경
- 기존 PC UIA 방식의 속도 및 신뢰성 한계를 극복
- 루팅 안드로이드 + IRIS + Hyper-V 리눅스 조합을 통한 안정적인 다중 방 관리 시스템 구축
- 네이버 카페(F-E) 커뮤니티의 최신 기술 트렌드 및 노하우 적용

### 프로젝트 목표
1. **안정성**: 99.9% 이상의 서비스 가용성 보장
2. **확장성**: 50개 이상의 오픈채팅방 동시 관리
3. **자동화**: 최소한의 개입으로 전체 운영 자동화
4. **모니터링**: 실시간 상태 모니터링 및 알림 시스템

---

## 🎯 핵심 기능 요구사항

### 1. IRIS 기반 메시지 처리 시스템

#### 1.1 기술적 요구사항
- **IRIS 설치**: 2025년 7월 기준 최신 버전 사용
- **연결 방식**: WebSocket 기반 실시간 이벤트 스트림
- **지원 이벤트**: `message`, `join`, `leave`, `kick`, `profile_change`
- **처리 속도**: 이벤트 수신 후 2초 이내 처리 완료

#### 1.2 구현 상세
```python
# 예상 구조
src/
├── bot/
│   ├── main.py              # IRIS 연결 및 이벤트 루프
│   ├── event_handlers/      # 이벤트별 핸들러
│   │   ├── message_handler.py
│   │   ├── join_handler.py
│   │   └── leave_handler.py
│   └── commands/            # 명령어 처리 모듈
│       ├── command_router.py
│       ├── help_command.py
│       ├── admin_command.py
│       └── api_command.py
```

#### 1.3 성능 기준
- **처리량**: 초당 100개 이상의 이벤트 처리
- **응답시간**: 평균 1.5초, 최대 3초
- **가용성**: 99.9% (월간 다운타임 43분 이내)

### 2. 다중 방 관리 시스템

#### 2.1 방 관리 기능
- **방 등록**: 최대 50개 오픈채팅방 동시 등록
- **방 상태 모니터링**: 실시간 연결 상태 확인
- **자동 재연결**: 연결 끊김 시 5초 간격 재시도
- **방별 설정**: 각 방의 독립적인 설정 관리

#### 2.2 메시지 저장 및 검색
- **저장 형식**: 구조화된 JSON 로그
- **보관 기간**: 최소 90일, 권장 1년
- **검색 기능**: 날짜, 사용자, 키워드 기반 검색
- **통계 제공**: 일별/주별/월별 활동 통계

#### 2.3 데이터 구조
```json
{
  "event_id": "uuid",
  "timestamp": "2025-10-27T10:30:00Z",
  "room_id": "room123",
  "event_type": "message",
  "user": {
    "id": "user456",
    "name": "사용자명",
    "profile_image": "url"
  },
  "content": {
    "text": "메시지 내용",
    "mentions": [],
    "attachments": []
  }
}
```

### 3. 환영 메시지 자동화 시스템

#### 3.1 환영 기능
- **트리거**: `join` 이벤트 감지 시 자동 실행
- **개인화**: 사용자 이름 포함 맞춤 메시지
- **멀티미디어**: 텍스트 + 이미지 동시 전송
- **중복 방지**: 동일 사용자 24시간 내 재환영 방지

#### 3.2 템플릿 시스템
```
config/templates/welcome/
├── default.json           # 기본 환영 템플릿
├── premium.json          # 프리미엄 방 템플릿
├── community.json        # 커뮤니티 방 템플릿
└── images/
    ├── welcome_default.png
    ├── rules.png
    └── guide.png
```

#### 3.3 템플릿 포맷
```json
{
  "message_template": "🎉 {username}님, {room_name}에 오신 것을 환영합니다!",
  "delay_seconds": 2,
  "include_image": true,
  "image_path": "images/welcome_default.png",
  "additional_messages": [
    "📖 규칙 안내: [규칙 링크]",
    "❓ 도움이 필요하면 !help를 입력해주세요"
  ]
}
```

### 4. 명령어 처리 시스템

#### 4.1 지원 명령어 목록
| 명령어 | 기능 | 권한 | 설명 |
|--------|------|------|------|
| `!help` | 도움말 | 모두 | 사용 가능한 명령어 목록 |
| `!stats` | 통계 | 관리자 | 방/서버 통계 정보 |
| `!announce <메시지>` | 공지 | 관리자 | 전체 방 공지 발송 |
| `!ban <유저>` | 차단 | 관리자 | 사용자 차단 |
| `!unban <유저>` | 차단해제 | 관리자 | 사용자 차단 해제 |
| `!restart` | 재시작 | 운영자 | 봇 재시작 |
| `!config <key> <value>` | 설정 | 관리자 | 동적 설정 변경 |

#### 4.2 명령어 처리 로직
```python
class CommandHandler:
    def __init__(self):
        self.commands = {
            'help': HelpCommand(),
            'stats': StatsCommand(),
            'announce': AnnounceCommand(),
            'config': ConfigCommand()
        }

    async def handle_command(self, message):
        if not message.text.startswith('!'):
            return None

        parts = message.text.split()
        command = parts[0][1:]  # ! 제거
        args = parts[1:] if len(parts) > 1 else []

        if command in self.commands:
            return await self.commands[command].execute(args, message)

        return "알 수 없는 명령어입니다. !help를 입력해보세요."
```

### 5. 방송 메시지 시스템

#### 5.1 방송 기능
- **일괄 전송**: 등록된 모든 방에 동일 메시지 전송
- **선택적 전송**: 특정 그룹/조건에 맞는 방만 선택
- **스케줄링**: 예약된 시간에 자동 전송
- **진행률 표시**: 실시간 전송 현황 모니터링

#### 5.2 큐 관리 시스템
```python
class BroadcastQueue:
    def __init__(self):
        self.queue = asyncio.Queue()
        self.processing = False

    async def add_broadcast(self, message, target_rooms=None, schedule=None):
        broadcast = {
            'id': generate_uuid(),
            'message': message,
            'target_rooms': target_rooms or self.get_all_rooms(),
            'schedule': schedule,
            'status': 'pending',
            'created_at': datetime.now()
        }
        await self.queue.put(broadcast)
        return broadcast['id']
```

#### 5.3 전송 결과 보고
- **성공률**: 방별 전송 성공/실패 현황
- **실패 원인**: 상세한 실패 로그 및 재시도 횟수
- **소요 시간**: 전체 방송 시작부터 완료까지의 시간
- **요약 보고**: Slack/Email로 자동 보고서 전송

---

## 🔧 기술적 구현 상세

### 1. 시스템 아키텍처

#### 1.1 전체 구조
```
┌─────────────────────────────────────────────────────────────┐
│                    관리자 인터페이스 (CLI/Web)              │
├─────────────────────────────────────────────────────────────┤
│                    API Gateway (FastAPI)                   │
├─────────────────────────────────────────────────────────────┤
│  Command Service  │  Welcome Service  │  Broadcast Service │
├─────────────────────────────────────────────────────────────┤
│                  Message Store (SQLite/PostgreSQL)         │
├─────────────────────────────────────────────────────────────┤
│                    Event Bus (Redis)                       │
├─────────────────────────────────────────────────────────────┤
│                    IRIS Connector (WebSocket)              │
├─────────────────────────────────────────────────────────────┤
│ 루팅 안드로이드 단말 1 │ 루팅 안드로이드 단말 2 │  ...        │
└─────────────────────────────────────────────────────────────┘
```

#### 1.2 핵심 컴포넌트

**IRIS Connector**
- WebSocket 연결 관리
- 이벤트 수신 및 파싱
- 자동 재연결 로직
- 메시지 전송 API

**Event Bus**
- Redis Pub/Sub 기반 메시지 버스
- 각 서비스 간 비동기 통신
- 이벤트 기록 및 재생 기능

**Message Store**
- SQLite (개발) / PostgreSQL (운영)
- 메시지 메타데이터 저장
- 검색 및 통계 기능
- 데이터 백업 및 복구

### 2. 개발 환경 요구사항

#### 2.1 하드웨어 요구사항
- **CPU**: 최소 4코어, 권장 8코어 이상
- **메모리**: 최소 8GB, 권장 16GB 이상
- **저장공간**: 최소 100GB, 권장 500GB (SSD 권장)
- **네트워크**: 안정적인 인터넷 연결 (최소 10Mbps)

#### 2.2 소프트웨어 요구사항
- **OS**: Windows 10/11 (Hyper-V 지원), Ubuntu 22.04+, CentOS 8+
- **Hyper-V**: External vSwitch 구성 가능
- **Python**: 3.9 이상
- **IRIS**: 최신 안정 버전 (2025년 7월 기준)
- **Redis**: 6.0 이상
- **PostgreSQL**: 13 이상 (운영 환경)

#### 2.3 개발 도구
- **IDE**: VSCode, PyCharm
- **버전 관리**: Git
- **컨테이너**: Docker (선택사항)
- **모니터링**: Prometheus + Grafana

### 3. 보안 및 제어 사항

#### 3.1 인증 및 권한
- **API 인증**: JWT 토큰 기반
- **명령어 권한**: 역할 기반 접근 제어 (RBAC)
- **방 접근 제어**: 관리자 승인된 방만 등록
- **운영자 권한**: 최소 권한 원칙 적용

#### 3.2 데이터 보호
- **암호화**: 전송 중 데이터 (TLS 1.3)
- **저장 데이터**: 민감 정보 암호화 저장
- **개인정보**: 수집 최소화 및 보관 기간 제한
- **로그 관리**: 개인정보 포함 로그 마스킹

#### 3.3 카카오 정책 준수
- **이용 약관**: 카카오톡 이용약계 준수
- **전송 제한**: 초당 전송량 제한 (스팸 방지)
- **계정 관리**: 디바이스/계정 제한 고려
- **콘텐츠 필터링**: 부적절 콘텐츠 자동 차단

---

## 📈 성능 및 모니터링

### 1. 성능 지표

#### 1.1 핵심 KPI
| 지표 | 목표 | 측정 방법 | 임계값 |
|------|------|-----------|--------|
| 메시지 처리량 | 100 msg/s | IRIS 이벤트 카운트 | < 50 msg/s (경고) |
| 응답 시간 | < 3초 | end-to-end 측정 | > 5초 (경고) |
| 가용성 | 99.9% | 서버 업타임 | < 99% (심각) |
| 에러률 | < 0.1% | 실패 건수/전체 건수 | > 1% (경고) |
| 메모리 사용량 | < 2GB | 시스템 모니터링 | > 4GB (경고) |

#### 1.2 모니터링 항목
- **시스템 리소스**: CPU, 메모리, 디스크, 네트워크
- **애플리케이션**: 요청 수, 응답 시간, 에러률
- **IRIS 연결**: 연결 상태, 재연결 횟수
- **방 상태**: 활성 방 수, 메시지 처리량

### 2. 로깅 및 추적

#### 2.1 로그 레벨
- **DEBUG**: 상세한 디버깅 정보
- **INFO**: 일반적인 상태 변화
- **WARNING**: 잠재적인 문제
- **ERROR**: 처리된 에러
- **CRITICAL**: 심각한 시스템 오류

#### 2.2 로그 포맷
```json
{
  "timestamp": "2025-10-27T10:30:00.123Z",
  "level": "INFO",
  "service": "message_handler",
  "event_id": "uuid",
  "room_id": "room123",
  "user_id": "user456",
  "message": "Message processed successfully",
  "duration_ms": 150,
  "metadata": {}
}
```

### 3. 알림 시스템

#### 3.1 알림 조건
- **심각**: 서비스 다운, 데이터베이스 연결 실패
- **경고**: IRIS 연결 끊김, 메모리 사용량 80% 이상
- **정보**: 새 방 등록, 시스템 재시작

#### 3.2 알림 채널
- **Slack**: 실시간 운영자 알림
- **Email**: 일일 요약 보고
- **SMS**: 심각 장애 발생 시

---

## 🚀 개발 단계별 계획

### Phase 1: 기반 인프라 구축 (2주)
- [x] 프로젝트 구조 설계
- [x] IRIS 연결 테스트
- [ ] 기본 로깅 시스템 구축
- [ ] 메시지 저장 기본 기능
- [ ] 간단한 명령어 처리기

### Phase 2: 핵심 기능 구현 (4주)
- [ ] 다중 방 추적 시스템
- [ ] 환영 메시지 자동화
- [ ] 기본적인 명령어 세트
- [ ] 에러 처리 및 재시도 로직
- [ ] 단위 테스트 코드 작성

### Phase 3: 고급 기능 및 안정화 (3주)
- [ ] 방송 메시지 시스템
- [ ] 스케줄링 기능
- [ ] 성능 최적화
- [ ] 모니터링 대시보드
- [ ] 통합 테스트

### Phase 4: 운영 준비 및 배포 (2주)
- [ ] 배포 자동화
- [ ] 운영 문서 작성
- [ ] 사용자 교육
- [ ] 프로덕션 환경 배포
- [ ] 안정화 및 모니터링

---

## 📋 기술 리스크 및 대응책

### 1. 기술적 리스크
| 리스크 | 확률 | 영향 | 대응책 |
|--------|------|------|--------|
| IRIS 연결 불안정 | 중간 | 높음 | 자동 재연결, 이중화 구성 |
| 루팅 단말 성능 저하 | 낮음 | 중간 | `iris_control` 모니터링, 예비 단말 확보 |
| 메시지 유실 | 낮음 | 높음 | 중복 검증, 재처리 큐 |
| 카카오 정책 변경 | 중간 | 높음 | 지속적인 모니터링, 유연한 아키텍처 |

### 2. 운영적 리스크
| 리스크 | 확률 | 영향 | 대응책 |
|--------|------|------|--------|
| 디스크 공간 부족 | 중간 | 중간 | 자동 로그 정리, 모니터링 |
| 네트워크 장애 | 낮음 | 높음 | 이중 네트워크 구성 |
| 권한 문제 | 낮음 | 중간 | 최소 권한 원칙, 정기 검토 |

---

## 📚 추가 고려사항

### 1. 확장성
- **수평 확장**: 여러 루팅 단말과 Hyper-V 봇 노드로 부하 분산
- **수직 확장**: 단일 단말/봇 자원 최적화
- **클라우드 전환**: 향후 클라우드 환경으로의 마이그레이션 고려

### 2. 유지보수
- **코드 품질**: 리뷰 프로세스, 코드 컨벤션
- **테스트 커버리지**: 최소 80% 이상 목표
- **문서화**: API 문서, 운영 가이드 자동화

### 3. 법적 준수
- **개인정보보호법**: 민감 정보 처리 규정 준수
- **저작권**: 오픈소스 라이선스 준수
- **서비스 이용약관**: 플랫폼 정책 준수

---

*문서 버전: v2.0*
*작성일: 2025-10-27*
*다음 리뷰: 2025-11-27*
